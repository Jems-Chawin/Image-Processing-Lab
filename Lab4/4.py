# -*- coding: utf-8 -*-
"""ImgProcessingLab4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19E_8V11ZusFJjMSRcgm_kx_Ov1ALxbot
"""

#Array, image processing
import cv2
import numpy as np
import matplotlib.pyplot as plt
#Model Operation
from keras import Model, Input
import keras.utils as image
import tensorflow as tf
from keras.wrappers.scikit_learn import KerasRegressor
from tensorflow.keras.preprocessing.image import load_img, img_to_array
from tensorflow.keras.layers import Dense, Conv2D, MaxPool2D, UpSampling2D
from tensorflow.keras.callbacks import EarlyStopping
from sklearn.model_selection import train_test_split
from sklearn.model_selection import GridSearchCV
from sklearn import metrics
# io
import glob
from tqdm import tqdm
import warnings;
warnings.filterwarnings('ignore')

image_paths = glob.glob("./face_mini/*/*.jpg")  # แทน path ที่มีภาพของคุณ
len(image_paths)

# Step 1: อ่านภาพและเก็บในรูปของ array
images = []

for image_path in tqdm(image_paths):
    img = load_img(image_path, target_size=(80, 80), interpolation="nearest")
    img_array = img_to_array(img)
    images.append(img_array)

print("Number of images loaded:", len(images))

# Step 2: ปรับสเกลและค่า intensity ของ pixel เป็น [0, 1]
images = np.array(images) / 255.0

# Step 3: Append ภาพไปยัง array
# ไม่จำเป็นต้องทำขั้นตอนนี้เนื่องจากภาพถูกเก็บไว้ใน images แล้ว

# Step 4: แบ่งชุดข้อมูลเป็น Training_data, Testing_data (70:30)
train_x, test_x = train_test_split(images, test_size=0.3, random_state=42)

# Step 5: แบ่งชุดข้อมูล Training_data เป็น Training_data, Validation_data (80:20)
train_x, val_x = train_test_split(train_x, test_size=0.2, random_state=42)

# Step 6: กำหนดพารามิเตอร์สำหรับ noise
noise_mean = 0
noise_std = 1
noise_factor = 0.3

# Step 7: สร้าง noise และเพิ่มลงในภาพ train_x, val_x, test_x
train_x_noise = train_x + (noise_factor * np.random.normal(loc=noise_mean, scale=noise_std, size=train_x.shape))
val_x_noise = val_x + (noise_factor * np.random.normal(loc=noise_mean, scale=noise_std, size=val_x.shape))
test_x_noise = test_x + (noise_factor * np.random.normal(loc=noise_mean, scale=noise_std, size=test_x.shape))

# Step 8: แสดงภาพเปรียบเทียบ ภาพที่เพิ่ม noise และภาพต้นฉบับ

index = 0  # แทนดัชนีของภาพที่คุณต้องการแสดงเปรียบเทียบ

plt.figure(figsize=(10, 10))
for index in range(5):
  plt.subplot(2, 5, index+1)
  plt.imshow(train_x[index])
  plt.title("Original Image")
  plt.axis("off")

  plt.subplot(2, 5, index+6)
  plt.imshow(train_x_noise[index])
  plt.title("Noisy Image")
  plt.axis("off")

plt.tight_layout()
plt.show()

# end of 4.1

# input_img = Input(shape=(80,80,3))
# x1 = Conv2D(256,(3,3),activation='relu',padding='same')(input_img)
# x2 = Conv2D(128,(3,3),activation='relu',padding='same')(x1)
# x3 = MaxPool2D(pool_size=(2,2),strides=2)(x2)
# x4 = Conv2D(64,(3,3),activation='relu',padding='same')(x3)
# x5 = Conv2D(64,(3,3),activation='relu',padding='same')(x4)
# x6 = UpSampling2D(interpolation='nearest',size=(2,2))(x5)
# x7 = Conv2D(128,(3,3),activation='relu',padding='same')(x6)
# x8 = Conv2D(256,(3,3),activation='relu',padding='same')(x7)
# decoded_img = Conv2D(3,(3,3),activation='relu',padding='same')(x8)
# a = Model(input_img, decoded_img)
# a.compile(optimizer='adam', loss='mse')
# a.summary()

# epochs = 32
# batch_size = 16
# callback = EarlyStopping(monitor='loss', patience=3)
# history = a.fit(train_x_noise, train_x, epochs=epochs, batch_size=batch_size, shuffle=True, validation_data=(val_x_noise, val_x), callbacks=[callback], verbose=1)

# plt.figure(figsize=(10,10))
# plt.plot(history.history['loss'],'b')
# plt.plot(history.history['val_loss'],'r--',lw=2)
# plt.title('Loss')
# plt.ylabel('loss')
# plt.xlabel('epoch')
# plt.legend(['train', 'val'], loc='upper right')
# plt.show()
# plt.savefig('plot.png')

# x_test_predicted = a.predict(test_x_noise)

# plt.figure(figsize=(8,8))
# n = 5
# for i in range(n):
# 	plt.subplot(3, 5, i+1)
# 	plt.imshow(test_x[i])
# 	plt.title('Ground truth')
# 	plt.axis('off')

# 	plt.subplot(3, 5,n+ i+1)
# 	plt.imshow(test_x_noise[i])
# 	plt.title('Noisy image')
# 	plt.axis('off')

# 	plt.subplot(3, 5,2*n + i+1)
# 	plt.imshow(x_test_predicted[i])
# 	plt.title('Predicted image')
# 	plt.axis('off')
# plt.tight_layout()
# plt.show()
# plt.savefig('predicted.png')

# # end of 4.2